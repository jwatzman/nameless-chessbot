- transposition table
	- does zeroing the table matter? i don't think so?
	- eviction policy: move to two-buckets, one always-replace, one current algo http://mediocrechess.sourceforge.net/guides/transpositiontables.html
		- this didn't seem to help?
	- improve replacement algo -- don't replace deep search from 1 generation ago with shallow search now
		- need to be careful testing this, search-perf invalidates the table
	- try to make tt node smaller
- improve timer
	- deal with "level x x:xx x" format
	- check time every N nodes searched instead of alarm
	- allows time to be increased, e.g., if hit aspiration failure
	- allows computing remaining time, e.g., if about to start another ply but there's very little time left
		- assume next ply will take AT LEAST twice current spent
	- allow knowing the root is *almost* done and could use a little more time
	- do something with fixed time, e.g., in 2+1 we just use the 1 right now!
- pondering
	- maybe straightforward with pthreads and manually forcing a timeup?
	- always move search into a thread so it can be interrupted?
	- need to be careful of atomic access / memory barriers
- move ordering
	- SEE
		- http://mediocrechess.sourceforge.net/guides/see.html
	- can we do any ordering on non-captures?
		- there's something where you make sure you aren't moving a queen to be attacked by a pawn (generally, lower-value piece)
- alpha-beta
	- move to separate qsearch function? easier to reason about at least
	- I think I'm half-fail-soft -- go all the way? https://www.chessprogramming.org/Alpha-Beta#Outside_the_Bounds
	- history heuristic: add points per depth; don't clear table every move but halve every value or something
	- enable null move, see what's going on there
		- better zugzwang detection?
		- test positions: https://www.chessprogramming.org/Null_Move_Test-Positions
	- futility pruning
	- threat detection https://www.chessprogramming.org/Null_Move_Pruning#ThreatDetection
